package main

import (
    "testing"
    "github.com/Shopify/sarama"
    "log"
    "sync"
    "time"
)

// Test if market data and order commands are correctly produced and consumed
func TestOrderPlacedNotification(t *testing.T) {
    brokers := []string{"localhost:9092"}
    producer, err := NewOrderCommandProducer(brokers)
    if err != nil {
        t.Fatalf("Failed to create producer: %v", err)
    }

    // Set up consumers for the various subsystems
    tradingConsumer, err := NewTradingEngineConsumer(brokers)
    if err != nil {
        t.Fatalf("Failed to create trading engine consumer: %v", err)
    }

    portfolioConsumer, err := NewPortfolioManagerConsumer(brokers)
    if err != nil {
        t.Fatalf("Failed to create portfolio manager consumer: %v", err)
    }

    auditLogger, err := NewAuditLogger(brokers)
    if err != nil {
        t.Fatalf("Failed to create audit logger: %v", err)
    }

    var wg sync.WaitGroup
    wg.Add(3)

    go func() {
        defer wg.Done()
        tradingConsumer.ProcessOrders()
    }()
    go func() {
        defer wg.Done()
        portfolioConsumer.UpdatePortfolio()
    }()
    go func() {
        defer wg.Done()
        auditLogger.LogActivities()
    }()

    // Produce an "Order Placed" message
    err = producer.SendOrder("1001", "501", "AAPL", 10, "buy", time.Now().Unix())
    if err != nil {
        t.Fatalf("Failed to send order: %v", err)
    }

    // Wait for consumers to process the message
    time.Sleep(2 * time.Second)
    wg.Wait()

    // Further checks: You would typically include verification that the consumers have processed the message correctly.
    // This may involve checking some state changes, logs, or outputs generated by the consumers.
}

// Test handling of duplicate orders
func TestDuplicateOrders(t *testing.T) {
    brokers := []string{"localhost:9092"}
    producer, err := NewOrderCommandProducer(brokers)
    if err != nil {
        t.Fatalf("Failed to create producer: %v", err)
    }

    orderID := "1002"
    // Send the same order twice
    err = producer.SendOrder(orderID, "502", "GOOGL", 15, "buy", time.Now().Unix())
    if err != nil {
        t.Fatalf("Failed to send order: %v", err)
    }
    err = producer.SendOrder(orderID, "502", "GOOGL", 15, "buy", time.Now().Unix())
    if err != nil {
        t.Fatalf("Failed to send duplicate order: %v", err)
    }

    // Further checks: Ensure that the system handles duplicate orders correctly, such as only processing the order once.
}

// Test the system's response to invalid stock orders
func TestInvalidStockOrders(t *testing.T) {
    brokers := []string{"localhost:9092"}
    producer, err := NewOrderCommandProducer(brokers)
    if err != nil {
        t.Fatalf("Failed to create producer: %v", err)
    }

    // Send an order for a non-existent stock
    err = producer.SendOrder("1003", "503", "INVALID", 5, "buy", time.Now().Unix())
    if err == nil {
        t.Fatalf("Expected error for invalid stock order, got nil")
    }

    // Further checks: Verify that invalid orders do not result in system crashes and are properly logged or discarded.
}

// Test how the system handles high-frequency data
func TestRateLimiting(t *testing.T) {
    brokers := []string{"localhost:9092"}
    producer, err := NewMarketDataProducer(brokers)
    if err != nil {
        t.Fatalf("Failed to create producer: %v", err)
    }

    // Simulate high-frequency market data publishing
    for i := 0; i < 1000; i++ {
        err = producer.Publish("AAPL", float64(100+i), time.Now().Unix())
        if err != nil {
            t.Fatalf("Failed to send market data: %v", err)
        }
    }

    // Further checks: Validate that consumers handle the high load properly without missing messages or crashing.
}

// Test proper handling and logging of all activities
func TestAuditLogging(t *testing.T) {
    brokers := []string{"localhost:9092"}
    auditLogger, err := NewAuditLogger(brokers)
    if err != nil {
        t.Fatalf("Failed to create audit logger: %v", err)
    }

    var wg sync.WaitGroup
    wg.Add(1)

    go func() {
        defer wg.Done()
        auditLogger.LogActivities()
    }()

    // Produce multiple messages for audit
    producer, err := NewOrderCommandProducer(brokers)
    if err != nil {
        t.Fatalf("Failed to create producer: %v", err)
    }

    // Send several orders to generate logs
    for i := 0; i < 5; i++ {
        err = producer.SendOrder(fmt.Sprintf("100%d", i), "504", "TSLA", 10*i, "sell", time.Now().Unix())
        if err != nil {
            t.Fatalf("Failed to send order: %v", err)
        }
    }

    // Wait for the logger to process messages
    time.Sleep(2 * time.Second)
    wg.Wait()

    // Further checks: Ensure that all relevant actions are logged accurately and completely.
}
